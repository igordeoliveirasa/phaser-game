extends layout

block content
    .content
        h1= title
        p A combination of neural networks and genetic algorithm

    script.

        function createFood(game, x, y, w, color) {
            var sprite = createCircle(game, x, y, w, null, null, color);
            return sprite;
        }

        function getClosestFood(individual, foods) {
            var closestDistance = null
            var closestFood = null;

            for (var i=0; i<foods.children.length; i++) {
                var food = foods.getAt(i);
                if (food.alive) {
                    var distance = calculateDistance(individual.shape.x, individual.shape.y, food.x, food.y);
                    if ( !closestDistance || !closestFood || distance < closestDistance) {
                        closestDistance = distance;
                        closestFood = food;
                    }
                }
            }
            return closestFood;
        }

        screenWidth = 500;
        screenHeight = 500;

        lblGeneration = "Generation: 0";
        game = new Phaser.Game(screenWidth, screenHeight, Phaser.AUTO, '', {preload: preload, create: create, update: update});


        maxFood = 50;

        var foods = null;

        MAX_INDIVIDUALS = 50;
        brains = [];
        population = [];
        generation = 0;
        generationTimeInSeconds = 2;

        lastId = 0;
        function generateId() {
            lastId += 1;
            return lastId;
        }


        STARTED = false;

        function sortByHighestScore(population) {
            return population.sort(function(individualA, individualB) {
                return (individualB.score - individualA.score);
            });
        }

        function createFoods() {
            var foods = game.add.group();
            foods.enableBody = true;
            for (var i = 0; i < maxFood; i++) {
                foods.add(createFood(game, getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 5, COLOR.BLUE));
            }
            return foods;
        }

        function getFittest(population) {
            var sorted = sortByHighestScore(population);
            return sorted[0];
        }

        function crossIndividuals(individualA, individualB) {
            var newBrain = crossoverAvg(individualA.brain, individualB.brain);
            // mutation rate: 1 in 100
            if (getRandomInt(1,100)==1) {
                newBrain = mutate(newBrain);
                console.log("mutation occurred!");
            }
            return new Individual(game, generateId(), getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 10, getRandomInt(-360, 360), COLOR.BLACK, newBrain, 0);
        }

        function generationManager(){

            STARTED = false;
            generation += 1;

            var brains = [];
            var newPopulation = [];

            if (generation==1) {
                // generating population
                for (var i = 0; i < MAX_INDIVIDUALS; i++) {
                    var brain = createBrain();
                    fillBrainRandomically(brain)
                    //brains.push(brain);
                    var individual = new Individual(game, generateId(), getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 10, getRandomInt(-360, 360), COLOR.BLACK, brain, 0);
                    newPopulation.push(individual);
                }
            }
            else {
                game.world.removeAll();

                // getting fittest individual
                var fittestIndividual = getFittest(population);

                // elitism
                newPopulation.push(fittestIndividual);

                // only mutation
                //                for (var i=newPopulation.length; i<MAX_INDIVIDUALS; i++) {
                //                    var newBrain = mutate(fittestIndividual.brain);
                //                    var individual = new Individual(game, generateId(), getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 10, getRandomInt(-360, 360), COLOR.BLACK, newBrain, 0);
                //                    newPopulation.push();
                //                }

                // crossing with the bests
                if (fittestIndividual.score > 0) {
                    for (var i=newPopulation.length; i<MAX_INDIVIDUALS; i++) {
                        var parent = population[i];
                        if (parent.id != fittestIndividual.id && parent.score>0) {
                            //var newBrain = crossoverAvg(fittestIndividual.brain, parent.brain);
                            //                            var newBrain = crossover(fittestIndividual.brain, parent.brain);
                            //                            // mutation rate: 1 in 100
                            //                            if (getRandomInt(1,100)==1) {
                            //                                newBrain = mutate(newBrain);
                            //                                console.log("mutation occurred!");
                            //                            }
                            //                            var individual = new Individual(game, generateId(), getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 10, getRandomInt(-360, 360), COLOR.BLACK, newBrain, 0);
                            newPopulation.push(crossIndividuals(fittestIndividual, parent));
                            newPopulation.push(crossIndividuals(parent, fittestIndividual));
                        }
                    }
                }


                //                // crossing with anyone in order to fill up
                //                while (newPopulation.length<MAX_INDIVIDUALS) {
                //                    var parent = population[getRandomInt(0,MAX_INDIVIDUALS-1)];
                //                    if (parent.id != fittestIndividual.id) {
                //                        var newBrain = crossover(fittestIndividual.brain, parent.brain);
                //                        if (getRandomInt(1, 100) == 1) {
                //                            newBrain = mutate(newBrain);
                //                            console.log("mutation occurred!");
                //                        }
                //                        var individual = new Individual(game, generateId(), getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 10, getRandomInt(-360, 360), COLOR.BLACK, newBrain, 0);
                //                        newPopulation.push(individual);
                //                    }
                //                }

                // crossing with anyone in order to fill up
                while (newPopulation.length<MAX_INDIVIDUALS) {
                    var parentA = population[getRandomInt(0,MAX_INDIVIDUALS-1)];
                    var parentB = population[getRandomInt(0,MAX_INDIVIDUALS-1)];
                    if (parentA.id != parentB.id) {
                    //                        var newBrain = crossover(parentA.brain, parentB.brain);
                    //                        if (getRandomInt(1, 100) == 1) {
                    //                            newBrain = mutate(newBrain);
                    //                            console.log("mutation occurred!");
                    //                        }
                    //                        var individual = new Individual(game, generateId(), getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 10, getRandomInt(-360, 360), COLOR.BLACK, newBrain, 0);
                    //                        newPopulation.push(individual);
                        newPopulation.push(crossIndividuals(parentA, parentB));
                        newPopulation.push(crossIndividuals(parentB, parentA));
                    }
                }
            }

            // creating creatures
            foods = createFoods();

            population = [];
            for (var i = 0; i < newPopulation.length; i++) {
                var individual = newPopulation[i];
                individual.firstClosestFood = getClosestFood(individual, foods);
                population.push(individual);
            }

            lblGeneration = game.add.text(16, 16, 'Generation: ' + generation, { fontSize: '16px', fill: '#000' });
            lbPopulation = game.add.text(16, 36, 'Population: ' + population.length, {fontSize: '16px', fill: '#000'});


            STARTED = true;

            setTimeout(function(){ generationManager() }, generationTimeInSeconds * 1000);
        };

        function create() {
            game.physics.startSystem(Phaser.Physics.ARCADE);

        };

        function preload() {
            game.stage.backgroundColor =  COLOR.WHITE;
            cursors = game.input.keyboard.createCursorKeys();
            generationManager();
        };

        function hasEaten(organismShape, food) {
            food.kill();
            for (var i = foods.countLiving(); i < maxFood; i++) {
                foods.add(createFood(game, getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 5, COLOR.BLUE));
            }
        }

        function update() {
            //game.physics.arcade.collide(player, foods);

            if (STARTED) {
                for (var i=0; i<population.length; i++) {
                    var individual = population[i];
                    if (game.physics.arcade.overlap(individual.shape, foods, hasEaten, null, this)) {
                        individual.score += 1;
                    };

                    target = getClosestFood(individual, foods);
                    if (target) {
                        var prediction = individual.brain.predict([[individual.angle, target.x - individual.shape.x, target.y - individual.shape.y]]);
                        //console.log("Prediction: " + prediction);
                        var left = prediction[0][0] >= 0.5;
                        var right = prediction[0][1] >= 0.5;
                        individual.update(left, right);
                    }
                    // keyboard
                    //organism.update(cursors.up.isDown, cursors.left.isDown, cursors.right.isDown);
                }
            }
        };
