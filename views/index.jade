extends layout

block content
    h1= title
    p A combination of neural networks and genetic algorithm

    script.

        /*
        var x = [[200.0, 200.0, 90.0, 1.0, 200.0, 300.0]];
        var y = [[1,2,3]]
        var mlp = new ml.MLP({
            'input' : x,
            'label' : y,
            'n_ins' : 6,//x, y, angle, speed, x, y,
            'n_outs' : 3,
            'hidden_layer_sizes' : [3] // it coud be something like: [3,3,3] or [3,4,5] or anything
        });

        for (var i = 0; i < mlp.sigmoidLayers.length; i++) {
            if (i !== mlp.sigmoidLayers.length - 1) {
                console.log((i + 1) + "th hidden layer W : ", mlp.sigmoidLayers[i].W);
                console.log((i + 1) + "th hidden layer b : ", mlp.sigmoidLayers[i].b);
            } else {
                console.log("output layer W : " + mlp.sigmoidLayers[i].W);
                console.log("output layer b : " + mlp.sigmoidLayers[i].b);
            }
        }


        mlp.set('log level',1); // 0 : nothing, 1 : info, 2 : warning.
        mlp.train({
            'lr' : 0.6,
            'epochs' : 20000
        });

        a = [
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0]
        ];

        console.log(mlp.predict(a));
        */
        // --------------------------------------------------------------------

        COLOR = {
            BLACK : "#000000",
            WHITE: "#ffffff",
            BLUE: "#0000ff",
            RED: "#ff0000"
        };

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min );
        }

        function createCircle(game, x, y, w, lineWidthInString, strokeStyle, fillStyle) {
            // Create BitmapData
            var bmd = game.add.bitmapData(w, w)

            // Draw circle
            bmd.ctx.beginPath();

            if (strokeStyle) {
                bmd.ctx.strokeStyle = strokeStyle;
                bmd.ctx.stroke();
            }

            if (lineWidthInString) {
                bmd.ctx.lineWidth = lineWidthInString;
            }

            bmd.ctx.arc(w / 2, w / 2, w / 2, 0, Math.PI * 2, true);
            if (fillStyle) {
                bmd.ctx.fillStyle = fillStyle;
                bmd.ctx.fill();
            }

            bmd.ctx.closePath();

            var sprite = game.add.sprite(x, y, bmd);
            return sprite;
        };


        function createPlayer(game, x, y, w, color) {
            var player = createCircle(game, x, y, w, null, null, color);
            game.physics.arcade.enable(player);
            player.body.collideWorldBounds = true;
            player.body.bounce.y=0.25;
            return player;
        }

        function outstandCircle(game, x, y, w) {
            var sprite = createCircle(game, x, y, w, null, null, 'rgba(255,0,0,0.5)');
            return sprite;
        }

        function createFood(game, x, y, w, color) {
            var sprite = createCircle(game, x, y, w, null, null, color);
            return sprite;
        }

        function calculateDistance(x1, y1, x2, y2) {
            var xs = 0;
            var ys = 0;
            xs = Math.abs(x2 - x1);
            xs = xs * xs;

            ys = Math.abs(y2 - y1);
            ys = ys * ys;
            return Math.sqrt(xs + ys);
        }

        function getClosestFood(organism, foods) {
            var closestDistance = null
            var closestFood = null;

            for (var i=0; i<foods.children.length; i++) {
                var food = foods.getAt(i);
                if (food.alive) {
                    var distance = calculateDistance(organism._organism.x, organism._organism.y, food.x, food.y);
                    if ( !closestDistance || !closestFood || distance < closestDistance) {
                        closestDistance = distance;
                        closestFood = food;
                    }
                }
            }
            return closestFood;
        }

        var Organism = function(game, x, y, w, angle, color) {
            this._organism = createPlayer(game, x, y, w, color)
            this.angle = angle;
            this.speed = 0.0;
            this.maxSpeed = 2;
            this.acceleration = 0.1;
            this.reduction = 0.5;
            this.score = 0;
            this.brain = new ml.MLP({
                'input' : [
                    [100.0, 100.0, 0.0, 0.5, 110.0, 110.0],
                    [110.0, 110.0, 0.0, 0.5, 100.0, 100.0],
                ],
                'label' : [
                    [1.0, 0.0, 1.0],
                    [1.0, 1.0, 0.0],
                ],
                'n_ins' : 6,//x, y, angle, speed, x, y,
                'n_outs' : 3,
                'hidden_layer_sizes' : [3] // it coud be something like: [3,3,3] or [3,4,5] or anything
            });
            //            this.brain.train({
            //                'lr' : 0.6,
            //                'epochs' : 20000
            //            });

            // initializing randomically

            for (var i = 0; i < this.brain.sigmoidLayers.length; i++) {
                if (i !== this.brain.sigmoidLayers.length - 1) {
                    for (var j=0; j<this.brain.sigmoidLayers[i].W.length; j++) {
                        for (var k=0; k<this.brain.sigmoidLayers[i].W[j].length; k++) {
                            //console.log("antes: " + this.brain.sigmoidLayers[i].W[j][k]);
                            this.brain.sigmoidLayers[i].W[j][k] = getRandomInt(-100000000000000000, 100000000000000000) / 100000000000000000.0;
                            //console.log("depois: " + this.brain.sigmoidLayers[i].W[j][k]);
                        }
                    }

                    //console.log((i + 1) + "th hidden layer W : ", this.brain.sigmoidLayers[i].W);
                    //console.log((i + 1) + "th hidden layer b : ", this.brain.sigmoidLayers[i].b);
                } else {
                    //console.log("output layer W : " + mlp.sigmoidLayers[i].W);
                    //console.log("output layer b : " + mlp.sigmoidLayers[i].b);
                }
            }

            this.closestFood = getClosestFood(this, foods);

            this.update = function(isUpDown, isLeftDown, isRightDown) {
                if (isUpDown || isLeftDown || isRightDown) {
                    if (isUpDown)
                    {
                        this.speed += this.acceleration;
                    }
                    if (isLeftDown) {
                        this.angle -= 5 + this.speed;//(this.speed);
                    }
                    else if (isRightDown) {
                        this.angle += 5 + this.speed;//(this.speed);
                    }
                }

                if (!isUpDown)
                {
                    if (this.speed > 0) {
                        this.speed = this.speed - this.reduction;
                    }

                    if (this.speed < 0) {
                        this.speed = 0;
                    }
                }

                if (this.angle > 360) {
                    this.angle -= 360;
                }
                if (this.angle < -360) {
                    this.angle += 360;
                }

                lastX = this._organism.x;
                lastY = this._organism.y;
                if (this.speed > this.maxSpeed) {
                    this.speed = this.maxSpeed;
                }

                var radians = Math.PI/180 * this.angle;
                this._organism.x += this.speed * Math.cos(radians);
                this._organism.y += this.speed * Math.sin(radians);
            }
        }

        screenWidth = 800;
        screenHeight = 600;

        lblGeneration = "Generation: 0";
        game = new Phaser.Game(screenWidth, screenHeight, Phaser.AUTO, '', {preload: preload, create: create, update: update});
        maxFood = 200;

        foods = null;
        organisms = [];
        MAX_ORGANISMS = 30;
        generation = 0;
        generationTimeInSeconds = 5;

        STARTED = false;

        function sortByHighestScore(organisms) {
            return organisms.sort(function(organismA, organismB) {
                return (organismB.score - organismA.score);
            });
        }

        function generationManager(){

            STARTED = false;

            if (generation>0) {
                var sorted = sortByHighestScore(organisms);
                console.log(sorted);
                // var newBrains = crossover();
                console.log("continuar daqui ..");
            }

            generation += 1;

            game.world.removeAll()

            foods = game.add.group();
            foods.enableBody = true;
            for (var i = 0; i < maxFood; i++) {
                var x = getRandomInt(0, screenWidth);
                var y = getRandomInt(0, screenHeight);
                foods.add(createFood(game, x, y, 5, COLOR.BLUE));
            }

            lblGeneration = game.add.text(16, 16, 'Generation: ' + generation, { fontSize: '16px', fill: '#000' });

            // generating organisms
            for (var i = 0; i < MAX_ORGANISMS; i++) {
                var organism = new Organism(game, getRandomInt(0, screenWidth), getRandomInt(0, screenHeight), 10, 0, COLOR.BLACK);
                organisms.push(organism);
            }

            STARTED = true;

            setTimeout(function(){ generationManager() }, generationTimeInSeconds * 1000);
        };

        function create() {
            game.physics.startSystem(Phaser.Physics.ARCADE);
        };

        function preload() {
            game.stage.backgroundColor =  COLOR.WHITE;
            cursors = game.input.keyboard.createCursorKeys();
            generationManager();
        };

        function hasEaten(organism, food) {
            food.kill();
        }

        function update() {
            //game.physics.arcade.collide(player, foods);

            if (STARTED) {
                for (var i=0; i<organisms.length; i++) {
                    var organism = organisms[i];
                    if (game.physics.arcade.overlap(organism._organism, foods, hasEaten, null, this)) {
                        var antScore = organism.score
                        organism.score += 1;
                    };

                    /*
                    if (organism.closestFood) {
                        organism.closestFood.kill();
                    }*/
                    var closestFood = getClosestFood(organism, foods);
                    if (closestFood) {
                        //organism.closestFood = outstandCircle(game, closestFood.x - 5, closestFood.y - 5, 15, "40", COLOR.RED);
                        var x = [[]]
                        var xClosestFood = 0.0;
                        var yClosestFood = 0.0;
                        if (organism.closestFood) {
                            xClosestFood = organism.closestFood.x;
                            yClosestFood = organism.closestFood.y;
                        }
                        var prediction = organism.brain.predict([[organism._organism.x, organism._organism.y, organism.angle, organism.speed, xClosestFood, yClosestFood]]);
                        var isUpDown = prediction[0][0] >= 0.5;
                        var isLeftDown = prediction[0][1] >= 0.5;
                        var isRightDown = prediction[0][2] >= 0.5;
                        //console.log(isUpDown + " - " + isLeftDown + " - " + isRightDown)
                        //console.log(prediction[0][0] + " - " + prediction[0][1] + " - " + prediction[0][2])
                        organism.update(isUpDown, isLeftDown, isRightDown);
                    }
                    // keyboard
                    //organism.update(cursors.up.isDown, cursors.left.isDown, cursors.right.isDown);
                }
            }
        };
